第1天  Github
第2天  配置环境

一、感受：
用Print函数，让电脑打出“hello world”字样，感受到一种强烈的仪式感。
一种感觉，python和小汽车一样，都是人类自己创造出来方便生活的工具，但如果要真正得到这种便利，那就必须要学会这项工具。就像小汽车一样，当你坐上驾驶位，就进入了汽车的运作系统，而安装python、配置好环境，就仿佛获得一辆车，钻进去，感受到不一样的操作环境。学好了车，驾驭车，车会把你快速载向远方，学python，就如同学会了计算机语言，一旦能驾驭，你便拥有了快速抵达未来的工具。



第3天 编写加减乘除计算器

一、感受：
编了一个极傻瓜的计数器，好像有一点点意思。

二、知识点：
# ‘’’ “”” 注释之用

input 要求在展示端输入的内容
print  要求终端输出显出的内容

operator 运算符
first_number 左边变量
second_number 右边变量

type函数——类型
int 整数类型
str 文本类型

if 如果
elif 再如果
else 否则 


三、逻辑分析：
第一步：确定三个变量（运算符，要计算的两个数据），input输入的内容
第二步：确定两个运算变量的整数类型，并明确print输出内容的类型
第三步：用if…elif…else函数明确可运算的范围，根据运算符赋值的变化，再print输出计算公式和结果。

就像烧菜一样，先把食材摆出来，明确好哪些是主料、哪些是配料，定好量，切好，再安排好烧制工艺方法，这些都设定清楚，赋值，然后再丢给“电脑”这个“大厨”，它一会儿就做好了。

不明之处：’ ’ 两个单引号和（）括号中间的代码有什么本质的区别？

四、补充知识点：
（ ）tuple元组类型，不可变序列。
[ ] list列表可变序列 。
{ } dict字典数据类型， 可以是数字、字符串，也可以是元组。


第4天   控制流程

一、感受：
也许这就是数据处理的初始形态？

二、知识点：

if 搭配 else语句共同使用，如果if语句表件表达式结果为假，那么程序执行else语句后的代码。if语句最多只能有一个else语句，但可以有任意数量的elif语句。
elif(即else-if), 检查多个表达式是否为真
while语句：条件循环语句（一直循环，直到条件不再为真）
for语句：循环语句


% 取模—返回除法的余数 (取余）
** 幂—返回X的y次幂
// 取整除—返回商的整数部分
！= 不等于（比较两个对象是否不相等）
< > 不等于（比较两个对象是否不相等）


按位或：|
按位异或：^
按位与：&
移位: << ,   >>


+= 加法赋值运算符
1､（相加，然后返回值给前一个变量） 
eg: a=1 b=2 a+=b  print(a)   3

2､（字符串连接）
eg: a=‘1’  b=‘2’  a+=b  print(a)  12


%= 取模赋值运算符 
%s 是字符串对应的格式通配符，表示格式化一个对象为字符
%d 是数值整型对应的格式通配符，表示一个整数


三、逻辑分析：

第一步：用for语句明确数据范围
第二步：赋值
第三步：明确打印显示公式与结果
第四步：用while语句明确范围，套嵌if-else语句，明确打印规则，排除真的，打印假的。
最后：i += 1 加法赋值 i  (代表i +1之后还是i的值，范围依然在1-10区间。



第5天 数据容器

一、感受
内容非常多，有点吃不消、看不懂，学得有些吃力、不明就里，只好抄视频。感觉lambda匿名函数很难弄懂。


二、知识点：

swapcase( )  ：用于对字符串的大小写字母进行转换
sorted ：对所有可迭代的对象进行升序排列,返回的是一个新的 list
sort： 应用在 list 上的方法,对已经存在的列表进行操作，无返回值
reverse： 排序规则  reverse = True 降序排列  reverse = False 升序排列
counter函数：用来遍历列表中的所有元素，并将元素出现的次数记录下来
set 集合： 用来去掉列表中的重复元素，可以在for…in 里减少循环次数
lambda：是匿名函数，lambda会创建一个函数对象，但不会把这个函数对象赋给一个标识符；而def则会把函数对象赋值给一个变量
key：列表里面的每个值，对应字典就是每个键。sorted参数的key表示按元素的那一项的值进行排序
？？？sorted(counter.items( ), key=lambda x: x[1]) 的意思：  counter.items( ) 为待排序的对象；key=lambda x: x[1] 为对前面的对象中的下标第一项出现次数的值？（即value，词频统计数？下标是什么？为数值所取的编号即为下标？）的值进行排序。 key=lambda  变量：变量[维数] 。维数可以按照自己的需要进行设置。
dict类型counter的items方法，表示返回一个包含相应项(key, value)的元组列表。key即为单词，value即为单词出现的次数。
布尔值： 只有两个值，Ture和False.
[::-1]  涉及的数字倒序输出，反转。a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍，倒序，列表翻转。
slice切片需注意：切片的时间包含 开始 索引，不包含结尾，所以，为了不把需要取出的第一个字符切掉，需要往前多加一个字符。如：取第3到第8个字符，则[2:8]
int 整数类型 integer
str 字符串类型 string
bin 二进制类型 binary system
oct 八进制类型 octonary number system
hex 十六进制类型 hexadecimal


三、逻辑分析：
第一任务：字符串的基本处理
第一步：定义sample_text变量，把要分析的内容复制给变量
第二步：用str类型的replace方法进行替换。再打印。
              text = sample_text.replace(‘better’, ‘worse’)
第三步：将字符串分割，分割成 list, 再filtered变量存放被过滤后的单词
              words = text.split( ) 
              filtered = [ ]  
第四步：用for …in循环遍历一遍，用find方法查看己被分割的list判断是否包含要被剔除的元素ea。如果不包含ea，则赋值为< 0 (此处为什么不直接写-1?），由于字符串索引从0开始，包含ea则进入到0开始被索引（要被过滤掉），如果不包含则为-1,属于要被过滤后的list，被装入filtered变量里。最后再打印被过滤后的filtered变量内容。
      简言之：分割打散字符 —— 放出过滤器filter —— 用for…in遍历find找有ea元素的list，赋予<0的计算机索引值，将其归入不被索引的范围，即被过滤掉，用filtered过滤器留下不含ea元素的list，打印出来，达成任务。
      if word.find(‘ea’) <0——如果找到有ea元素，则记入不被索引范围，留下不含ea元素的word.
      filtered.append(word)——添加不含ea元素的word到过滤器里，更新列表，不返回任何值。（append，指将传入的对象附加(添加)到现有列表中）        
第五步：用swapcase() 方法用于对字符串的大小写字母进行转换。              


第二个任务：统计字符串样本中英文单词出现的次数
第一步：定义sample_text变量，把要分析的内容复制给变量
第二步：将字符串分割，分割成 element列表。
第三步：定义新的list变量words，存放处理过的单词
第四步：挑选出文本中的非单词符号，剔除。之后，元素长度len不为0的，则算正常单词，存入到变量words里面。打印出现的单词（己过滤掉重复出瑞的）。
第五步：采用key=lambda匿名赋值变量，按词频统计数降序排列。按词频数从大到小排列打印。


第三个任务：数组操作，进制转换
用a[::-1]翻转列表
把int类型元素拼接之前需变成一个包含str类型元素的列表。用’ ’(空字符串）和str类型的join方法连接列表里的元素。
’ ’(空字符串）：表示连接的时候元素间不用任何按符隔开。




第6､7天：统计函数词频

一、感想：
复习到这一天，感觉很累。好像学习激情消失了。又安慰自己毕竟花了钱，打肿了脸也要学完啊。虽然还是没有掌握到学python的精髓。

相关知识点：
key=lambda X: X[1]
x[1]表示x下标为1的值返还给x

用from …import …导入需要统计的文本
result = stats_word.stats_text(sample_text)
print(‘统计结果 ==>’, result)
输出统计结果。

def (define，定义函数的意思）
一般格式：
def函数名(参数1,参数2,……,参数N):
执行语句
如：
def stats_text_en(text):

注意：结尾要有冒号。

二、逻辑：
把命令语句事先写好，然后再导入要统计的文本，进行统计并排序。

三、疑问：
是不是以后可以这个文本直接替换成别的文本，然后，也能进行相关的词频统计呢？还是说，直接导入要替换的文章网页更方便？


第8天：异常处理

一、感想：
一般在运行的时候，如果有错，运作框内会提示错误出来，所以，不明白这个异常处理是不是有点儿多余？


相关知识点：
用try…except捕获异常， 
try:
    参数
except Exception as e:
    print(参数）

为什么是e?

traceback模块：跟踪异常返回信息
logging模块：Python内置的标准模块,主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回路等。

if not isinstance(text, str):
判断参数text 是不是 str 字符串类型，如果不是，则抛出ValueError异常

二、逻辑：
导入要分析的文本，再调用traceback 和 logging两个函数，报错，并找出错误的位置。

三、疑问：
是不是记住了python一些自带的命令模块，逻辑清晰写的复制粘帖，然后，用异常处理报错，基本啥事儿都可以解决了呀？


第9和10天：标准库和第三方库的调用

感受：
字太小，看得很累，对视力不好。视频的声音听得人犯困。
安装jiebar 的时候，因为是苹果系统，与视频讲的不一样，所以卡了很久。

知识点：
主要是jieba中文库分词的作用。
苹果系统采用的安装方法是直接进入到Anaconda Navigator里面—-environments---base(root)—-Open Terminal(终端）自行录入 install jieba即可。
后面要安装，直接运用此法就行。


第11天至第13天：实操

一、感想：
因为微信不支持，所以，没有感受到处理结果。所以，并没有兴奋。


相关知识点：
yagmail 快速发送邮件

requests  
爬虫的基本框架是获取HTML页面信息，解析页面信息，保存结果，requests模块是用于第一步获取HTML页面信息； requests库用于爬取HTML页面，提交网络请求，基于urllib,但比urllib更方便
对应http的不同请求类型，requests库有不同的方法：
1.requests.get():
获取HTML网页的主要方法，对应于HTTP的GET
2.requests.post():
向HTML网页提交POST请求的方法，对应于HTTP的POST
3.requests.head():
获取HTML网页头信息的方法，对应于HTTP的HEAD
4.requests.put():
向HTML网页提交PUT请求，对应于HTTP的PUT
5.requests.patch():
向HTML网页提交局部修改请求，对应于HTTP的PATCH
6.requests.delete():
向HTML页面提交删除请求，对应于HTTP的DELETE

def get_article():
      r = requests.get(‘网址’)
     
pyquery  
爬虫辅助利器,PyQuery可以方便地用来解析HTML内容,提取网页中的任何数据

     document = pyquery.PyQuery(r.text)

getpass
python内置的获取密码及用户名的模块

logging
Python内置的标准模块,主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回路等。

def get_article(): 
     r = requests.get(‘网址’)
     document = pyquery.PyQuery(r.text)
     return document(参数).text()

matplotlib
用来绘制柱状图。

numpy 是大量Python数学和科学计算包的基础。支持大量的维度数组和矩阵运算,对数组运算提供了大量的数学函数库!Numpy比Python列表更具优势,其中一个优势便是速度。机器学习算法中大部分都是调用Numpy库来完成基础数值计算的。

13天学习大总结：

1､实际从7月2日开始，断断续续花了近2个月时间。
2､半懂不懂，不知道入门了没有，不知道怎么样才算入门。也许是因为没能与实际工作生活相结合，所以，找不到感觉，学得很落寞。
3､其实也知道坚持到最后也许会有一定的好处，但目前为止，没有对实际生活（工作收入等）产生直接切入点，后续学习动力堪忧。
4､在反思自己当时是不是一时冲动的结果。
5､虽然自学是需要坚持的，但如果一开始没有得到实际的好处或者乐趣，或者说，并没有感知到学习它的直接效用，那如何继续？（我文科生，做运营的）
6､希望未来的工作中能需要接触哪怕是要懂得运用python，这样，才能不枉费这段时间的学习。
